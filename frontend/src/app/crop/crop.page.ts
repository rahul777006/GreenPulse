import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ToastController, LoadingController, AlertController } from '@ionic/angular';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { GoogleGenerativeAI } from '@google/generative-ai';

interface CropRecommendation {
  recommendations: string;
  language: string;
  timestamp: Date;
}

@Component({
  selector: 'app-crop',
  templateUrl: './crop.page.html',
  styleUrls: ['./crop.page.scss'],
  standalone: false,
})

export class CropPage implements OnInit {

  cropForm: FormGroup;
  isSubmitting = false;
  aiResponse: string = '';
  showResponse = false;
  selectedLanguage = 'English';
  currentLanguage = 'English'; // Track current UI language
  location = '';
  isPlaying = false;
  currentAudio: HTMLAudioElement | null = null;
  showFullResponse = false;
  isGeneratingAudio = false;
  // Language options
  languages = [
    { code: 'en', name: 'English', display: 'English' },
    { code: 'hi', name: 'Hindi', display: 'рд╣рд┐рдВрджреА' },
    { code: 'pa', name: 'Punjabi', display: 'рикрй░риЬри╛римрйА' }
  ];

  // Translations for UI text
  translations = {
    English: {
      title: 'Smart Crop Advisor',
      subtitle: 'Get personalized, smart recommendations for your farm',
      smartAnalysis: 'Smart Analysis',
      maxProfit: 'Max Profit',
      expertAdvice: 'Expert Advice',
      preferredLanguage: 'Preferred Language',
      farmDetails: 'Farm Details',
      location: 'Location (City/District)',
      locationPlaceholder: 'e.g., Ludhiana, Punjab',
      soilType: 'Soil Type',
      farmSize: 'Farm Size',
      environmentalConditions: 'Environmental Conditions',
      climateType: 'Climate Type',
      waterAvailability: 'Water Availability',
      plantingSeason: 'Planting Season',
      budgetExperience: 'Budget & Experience',
      budget: 'Budget (тВ╣)',
      budgetPlaceholder: '50000',
      farmingExperience: 'Farming Experience',
      additionalInfo: 'Additional Information (Optional)',
      previousCrops: 'Previous Crops Grown',
      previousCropsPlaceholder: 'e.g., Wheat, Rice, Cotton',
      specificRequirements: 'Specific Requirements/Goals',
      specificRequirementsPlaceholder: 'e.g., High profit, Low water usage, Organic farming',
      getRecommendations: 'Get AI Recommendations',
      analyzing: 'Analyzing your data...',
      cropRecommendations: 'ЁЯМ╛ Your Crop Recommendations',
      aiPoweredSuggestions: 'AI-powered suggestions for',
      stopAudio: 'Stop Audio',
      listenAudio: 'Listen (AI Voice)',
      generating: 'Generating...',
      readMore: 'Read More',
      shareRecommendations: 'Share Recommendations',
      getNewRecommendations: 'Get New Recommendations'
    },
    Hindi: {
      title: 'рд╕реНрдорд╛рд░реНрдЯ рдлрд╕рд▓ рд╕рд▓рд╛рд╣рдХрд╛рд░',
      subtitle: 'рдЕрдкрдиреЗ рдЦреЗрдд рдХреЗ рд▓рд┐рдП рд╡реНрдпрдХреНрддрд┐рдЧрдд, рд╕реНрдорд╛рд░реНрдЯ рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ',
      smartAnalysis: 'рд╕реНрдорд╛рд░реНрдЯ рд╡рд┐рд╢реНрд▓реЗрд╖рдг',
      maxProfit: 'рдЕрдзрд┐рдХрддрдо рд▓рд╛рдн',
      expertAdvice: 'рд╡рд┐рд╢реЗрд╖рдЬреНрдЮ рд╕рд▓рд╛рд╣',
      preferredLanguage: 'рдкрд╕рдВрджреАрджрд╛ рднрд╛рд╖рд╛',
      farmDetails: 'рдЦреЗрдд рдХрд╛ рд╡рд┐рд╡рд░рдг',
      location: 'рд╕реНрдерд╛рди (рд╢рд╣рд░/рдЬрд┐рд▓рд╛)',
      locationPlaceholder: 'рдЬреИрд╕реЗ, рд▓реБрдзрд┐рдпрд╛рдирд╛, рдкрдВрдЬрд╛рдм',
      soilType: 'рдорд┐рдЯреНрдЯреА рдХрд╛ рдкреНрд░рдХрд╛рд░',
      farmSize: 'рдЦреЗрдд рдХрд╛ рдЖрдХрд╛рд░',
      environmentalConditions: 'рдкрд░реНрдпрд╛рд╡рд░рдгреАрдп рд╕реНрдерд┐рддрд┐рдпрд╛рдВ',
      climateType: 'рдЬрд▓рд╡рд╛рдпреБ рдкреНрд░рдХрд╛рд░',
      waterAvailability: 'рдкрд╛рдиреА рдХреА рдЙрдкрд▓рдмреНрдзрддрд╛',
      plantingSeason: 'рдмреБрдЖрдИ рдХрд╛ рдореМрд╕рдо',
      budgetExperience: 'рдмрдЬрдЯ рдФрд░ рдЕрдиреБрднрд╡',
      budget: 'рдмрдЬрдЯ (тВ╣)',
      budgetPlaceholder: '50000',
      farmingExperience: 'рдЦреЗрддреА рдХрд╛ рдЕрдиреБрднрд╡',
      additionalInfo: 'рдЕрддрд┐рд░рд┐рдХреНрдд рдЬрд╛рдирдХрд╛рд░реА (рд╡реИрдХрд▓реНрдкрд┐рдХ)',
      previousCrops: 'рдкрд╣рд▓реЗ рдЙрдЧрд╛рдИ рдЧрдИ рдлрд╕рд▓реЗрдВ',
      previousCropsPlaceholder: 'рдЬреИрд╕реЗ, рдЧреЗрд╣реВрдВ, рдЪрд╛рд╡рд▓, рдХрдкрд╛рд╕',
      specificRequirements: 'рд╡рд┐рд╢рд┐рд╖реНрдЯ рдЖрд╡рд╢реНрдпрдХрддрд╛рдПрдВ/рд▓рдХреНрд╖реНрдп',
      specificRequirementsPlaceholder: 'рдЬреИрд╕реЗ, рдЙрдЪреНрдЪ рд▓рд╛рдн, рдХрдо рдкрд╛рдиреА рдХрд╛ рдЙрдкрдпреЛрдЧ, рдЬреИрд╡рд┐рдХ рдЦреЗрддреА',
      getRecommendations: 'AI рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ',
      analyzing: 'рдЖрдкрдХреЗ рдбреЗрдЯрд╛ рдХрд╛ рд╡рд┐рд╢реНрд▓реЗрд╖рдг рдХрд░ рд░рд╣реЗ рд╣реИрдВ...',
      cropRecommendations: 'ЁЯМ╛ рдЖрдкрдХреА рдлрд╕рд▓ рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ',
      aiPoweredSuggestions: 'рдХреЗ рд▓рд┐рдП AI-рдЖрдзрд╛рд░рд┐рдд рд╕реБрдЭрд╛рд╡',
      stopAudio: 'рдСрдбрд┐рдпреЛ рдмрдВрдж рдХрд░реЗрдВ',
      listenAudio: 'рд╕реБрдиреЗрдВ (AI рдЖрд╡рд╛рдЬрд╝)',
      generating: 'рддреИрдпрд╛рд░ рдХрд░ рд░рд╣реЗ рд╣реИрдВ...',
      readMore: 'рдФрд░ рдкрдврд╝реЗрдВ',
      shareRecommendations: 'рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ рд╕рд╛рдЭрд╛ рдХрд░реЗрдВ',
      getNewRecommendations: 'рдирдИ рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ'
    },
    Punjabi: {
      title: 'ри╕риори╛ри░риЯ рилри╕ри▓ ри╕ри▓ри╛ри╣риХри╛ри░',
      subtitle: 'риЖрикригрйЗ риЦрйЗрид ри▓риИ ри╡ри┐риЕриХридрйАриЧрид, ри╕риори╛ри░риЯ ри╕ри┐рилри╛ри░ри╕ри╝ри╛риВ рикрйНри░ри╛рикрид риХри░рйЛ',
      smartAnalysis: 'ри╕риори╛ри░риЯ ри╡ри┐ри╕ри╝ри▓рйЗри╕ри╝риг',
      maxProfit: 'ри╡рй▒риз ридрйЛриВ ри╡рй▒риз риорйБриири╛рилри╛',
      expertAdvice: 'риори╛ри╣ри░ ри╕ри▓ри╛ри╣',
      preferredLanguage: 'ридри░риЬрйАри╣рйА ринри╛ри╕ри╝ри╛',
      farmDetails: 'риЦрйЗрид рижри╛ ри╡рйЗри░ри╡ри╛',
      location: 'ри╕риери╛рии (ри╕ри╝ри╣ри┐ри░/риЬри╝ри┐ри▓рйНри╣ри╛)',
      locationPlaceholder: 'риЬри┐ри╡рйЗриВ, ри▓рйБризри┐риЖригри╛, рикрй░риЬри╛рим',
      soilType: 'риори┐рй▒риЯрйА рижрйА риХри┐ри╕рио',
      farmSize: 'риЦрйЗрид рижри╛ риЖриХри╛ри░',
      environmentalConditions: 'ри╡ри╛ридри╛ри╡ри░риг ри╕римрй░ризрйА ри╕риери┐ридрйАриЖриВ',
      climateType: 'риЬри▓ри╡ри╛рипрйВ рижрйА риХри┐ри╕рио',
      waterAvailability: 'рикри╛ригрйА рижрйА риЙрикри▓римризридри╛',
      plantingSeason: 'римрйАриЬри╛риИ рижри╛ риорйМри╕рио',
      budgetExperience: 'римриЬриЯ риЕридрйЗ ридриЬри░римри╛',
      budget: 'римриЬриЯ (тВ╣)',
      budgetPlaceholder: '50000',
      farmingExperience: 'риЦрйЗридрйА рижри╛ ридриЬри░римри╛',
      additionalInfo: 'ри╡ри╛ризрйВ риЬри╛ригриХри╛ри░рйА (ри╡ри┐риХри▓рикри┐риХ)',
      previousCrops: 'рикри╣ри┐ри▓ри╛риВ риЙриЧри╛риИриЖриВ риЧриИриЖриВ рилри╕ри▓ри╛риВ',
      previousCropsPlaceholder: 'риЬри┐ри╡рйЗриВ, риХригриХ, риЪри╛ри╡ри▓, риХрикри╛ри╣',
      specificRequirements: 'риЦри╛ри╕ ри▓рйЛрйЬри╛риВ/риЯрйАриЪрйЗ',
      specificRequirementsPlaceholder: 'риЬри┐ри╡рйЗриВ, риЬри╝ри┐риЖрижри╛ риорйБриири╛рилри╛, риШрй▒риЯ рикри╛ригрйА ри╡ри░ридрйЛриВ, риЬрйИри╡ри┐риХ риЦрйЗридрйА',
      getRecommendations: 'AI ри╕ри┐рилри╛ри░ри╕ри╝ри╛риВ рикрйНри░ри╛рикрид риХри░рйЛ',
      analyzing: 'ридрйБри╣ри╛рибрйЗ рибрйЗриЯри╛ рижри╛ ри╡ри┐ри╕ри╝ри▓рйЗри╕ри╝риг риХри░ ри░ри╣рйЗ ри╣ри╛риВ...',
      cropRecommendations: 'ЁЯМ╛ ридрйБри╣ри╛рибрйАриЖриВ рилри╕ри▓ ри╕ри┐рилри╛ри░ри╕ри╝ри╛риВ',
      aiPoweredSuggestions: 'ри▓риИ AI-риЖризри╛ри░ри┐рид ри╕рйБриЭри╛риЕ',
      stopAudio: 'риЖрибрйАриУ римрй░риж риХри░рйЛ',
      listenAudio: 'ри╕рйБригрйЛ (AI риЖри╡ри╛риЬри╝)',
      generating: 'ридри┐риЖри░ риХри░ ри░ри╣рйЗ ри╣ри╛риВ...',
      readMore: 'ри╣рйЛри░ рикрйЬрйНри╣рйЛ',
      shareRecommendations: 'ри╕ри┐рилри╛ри░ри╕ри╝ри╛риВ ри╕ри╛риВриЭрйАриЖриВ риХри░рйЛ',
      getNewRecommendations: 'риири╡рйАриЖриВ ри╕ри┐рилри╛ри░ри╕ри╝ри╛риВ рикрйНри░ри╛рикрид риХри░рйЛ'
    }
  };

  // Soil types with translations
  soilTypesData = {
    English: [
      { value: 'Clay', label: 'Clay' },
      { value: 'Sandy', label: 'Sandy' },
      { value: 'Loamy', label: 'Loamy' },
      { value: 'Silt', label: 'Silt' },
      { value: 'Peaty', label: 'Peaty' },
      { value: 'Chalky', label: 'Chalky' },
      { value: 'Saline', label: 'Saline' }
    ],
    Hindi: [
      { value: 'Clay', label: 'рдорд┐рдЯреНрдЯреА (рдЪрд┐рдХрдиреА)' },
      { value: 'Sandy', label: 'рд░реЗрддреАрд▓реА рдорд┐рдЯреНрдЯреА' },
      { value: 'Loamy', label: 'рджреЛрдордЯ рдорд┐рдЯреНрдЯреА' },
      { value: 'Silt', label: 'рдЧрд╛рдж рдорд┐рдЯреНрдЯреА' },
      { value: 'Peaty', label: 'рдкреАрдЯ рдорд┐рдЯреНрдЯреА' },
      { value: 'Chalky', label: 'рдЪрд╛рдХреА рдорд┐рдЯреНрдЯреА' },
      { value: 'Saline', label: 'рдЦрд╛рд░реА рдорд┐рдЯреНрдЯреА' }
    ],
    Punjabi: [
      { value: 'Clay', label: 'риори┐рй▒риЯрйА (риЪри┐риХриирйА)' },
      { value: 'Sandy', label: 'ри░рйЗридри▓рйА риори┐рй▒риЯрйА' },
      { value: 'Loamy', label: 'рижрйЛриориЯ риори┐рй▒риЯрйА' },
      { value: 'Silt', label: 'риЧри╛риж риори┐рй▒риЯрйА' },
      { value: 'Peaty', label: 'рикрйАриЯ риори┐рй▒риЯрйА' },
      { value: 'Chalky', label: 'риЪри╛риХрйА риори┐рй▒риЯрйА' },
      { value: 'Saline', label: 'риЦри╛ри░рйА риори┐рй▒риЯрйА' }
    ]
  };

  // Climate conditions with translations
  climateTypesData = {
    English: [
      { value: 'Tropical', label: 'Tropical' },
      { value: 'Subtropical', label: 'Subtropical' },
      { value: 'Temperate', label: 'Temperate' },
      { value: 'Arid', label: 'Arid' },
      { value: 'Semi-arid', label: 'Semi-arid' },
      { value: 'Mediterranean', label: 'Mediterranean' }
    ],
    Hindi: [
      { value: 'Tropical', label: 'рдЙрд╖реНрдгрдХрдЯрд┐рдмрдВрдзреАрдп' },
      { value: 'Subtropical', label: 'рдЙрдкреЛрд╖реНрдгрдХрдЯрд┐рдмрдВрдзреАрдп' },
      { value: 'Temperate', label: 'рд╕рдорд╢реАрддреЛрд╖реНрдг' },
      { value: 'Arid', label: 'рд╢реБрд╖реНрдХ' },
      { value: 'Semi-arid', label: 'рдЕрд░реНрдзрд╢реБрд╖реНрдХ' },
      { value: 'Mediterranean', label: 'рднреВрдордзреНрдпрд╕рд╛рдЧрд░реАрдп' }
    ],
    Punjabi: [
      { value: 'Tropical', label: 'риЦрй░рибрйА' },
      { value: 'Subtropical', label: 'риЙрикриЦрй░рибрйА' },
      { value: 'Temperate', label: 'ри╕риори╕ри╝рйАридрйЛри╕ри╝риг' },
      { value: 'Arid', label: 'ри╕рйБрй▒риХри╛' },
      { value: 'Semi-arid', label: 'риЕри░риз-ри╕рйБрй▒риХри╛' },
      { value: 'Mediterranean', label: 'ринрйВриорй▒ризри╕ри╛риЧри░рйА' }
    ]
  };

  // Water availability with translations
  waterSourcesData = {
    English: [
      { value: 'Abundant (River/Canal)', label: 'Abundant (River/Canal)' },
      { value: 'Moderate (Bore well)', label: 'Moderate (Bore well)' },
      { value: 'Limited (Rain dependent)', label: 'Limited (Rain dependent)' },
      { value: 'Very Limited (Drought prone)', label: 'Very Limited (Drought prone)' }
    ],
    Hindi: [
      { value: 'Abundant (River/Canal)', label: 'рдкреНрд░рдЪреБрд░ (рдирджреА/рдирд╣рд░)' },
      { value: 'Moderate (Bore well)', label: 'рдордзреНрдпрдо (рдмреЛрд░рд╡реЗрд▓)' },
      { value: 'Limited (Rain dependent)', label: 'рд╕реАрдорд┐рдд (рдмрд╛рд░рд┐рд╢ рдкрд░ рдирд┐рд░реНрднрд░)' },
      { value: 'Very Limited (Drought prone)', label: 'рдмрд╣реБрдд рд╕реАрдорд┐рдд (рд╕реВрдЦрд╛ рдкреНрд░рд╡рдг)' }
    ],
    Punjabi: [
      { value: 'Abundant (River/Canal)', label: 'римри╣рйБрид (риирижрйА/риири╣ри┐ри░)' },
      { value: 'Moderate (Bore well)', label: 'риорй▒ризрио (римрйЛри░ри╡рйИрй▒ри▓)' },
      { value: 'Limited (Rain dependent)', label: 'ри╕рйАриорид (римри░ри╕ри╛рид ридрйЗ риири┐ри░ринри░)' },
      { value: 'Very Limited (Drought prone)', label: 'римри╣рйБрид ри╕рйАриорид (ри╕рйЛриХри╛ рикрйНри░ри╡ри╛риг)' }
    ]
  };

  // Farm sizes with translations
  farmSizesData = {
    English: [
      { value: 'Small (< 2 acres)', label: 'Small (< 2 acres)' },
      { value: 'Medium (2-10 acres)', label: 'Medium (2-10 acres)' },
      { value: 'Large (10-50 acres)', label: 'Large (10-50 acres)' },
      { value: 'Very Large (> 50 acres)', label: 'Very Large (> 50 acres)' }
    ],
    Hindi: [
      { value: 'Small (< 2 acres)', label: 'рдЫреЛрдЯрд╛ (< 2 рдПрдХрдбрд╝)' },
      { value: 'Medium (2-10 acres)', label: 'рдордзреНрдпрдо (2-10 рдПрдХрдбрд╝)' },
      { value: 'Large (10-50 acres)', label: 'рдмрдбрд╝рд╛ (10-50 рдПрдХрдбрд╝)' },
      { value: 'Very Large (> 50 acres)', label: 'рдмрд╣реБрдд рдмрдбрд╝рд╛ (> 50 рдПрдХрдбрд╝)' }
    ],
    Punjabi: [
      { value: 'Small (< 2 acres)', label: 'риЫрйЛриЯри╛ (< 2 риПриХрйЬ)' },
      { value: 'Medium (2-10 acres)', label: 'риорй▒ризрио (2-10 риПриХрйЬ)' },
      { value: 'Large (10-50 acres)', label: 'ри╡рй▒рибри╛ (10-50 риПриХрйЬ)' },
      { value: 'Very Large (> 50 acres)', label: 'римри╣рйБрид ри╡рй▒рибри╛ (> 50 риПриХрйЬ)' }
    ]
  };

  // Seasons with translations
  seasonsData = {
    English: [
      { value: 'Kharif (Monsoon)', label: 'Kharif (Monsoon)' },
      { value: 'Rabi (Winter)', label: 'Rabi (Winter)' },
      { value: 'Zaid (Summer)', label: 'Zaid (Summer)' },
      { value: 'Year Round', label: 'Year Round' }
    ],
    Hindi: [
      { value: 'Kharif (Monsoon)', label: 'рдЦрд░реАрдл (рдорд╛рдирд╕реВрди)' },
      { value: 'Rabi (Winter)', label: 'рд░рдмреА (рд╕рд░реНрджреА)' },
      { value: 'Zaid (Summer)', label: 'рдЬрд╛рдпрдж (рдЧрд░реНрдореА)' },
      { value: 'Year Round', label: 'рдкреВрд░реЗ рд╕рд╛рд▓' }
    ],
    Punjabi: [
      { value: 'Kharif (Monsoon)', label: 'риЦри░рйАрил (риори╛риири╕рйВрии)' },
      { value: 'Rabi (Winter)', label: 'ри░римрйА (ри╕ри░рижрйА)' },
      { value: 'Zaid (Summer)', label: 'риЬри╝ри╛риЗриж (риЧри░риорйА)' },
      { value: 'Year Round', label: 'ри╕ри╛ри░ри╛ ри╕ри╛ри▓' }
    ]
  };

  // Experience levels with translations
  experienceLevelsData = {
    English: [
      { value: 'Beginner (0-2 years)', label: 'Beginner (0-2 years)' },
      { value: 'Intermediate (3-10 years)', label: 'Intermediate (3-10 years)' },
      { value: 'Experienced (10+ years)', label: 'Experienced (10+ years)' }
    ],
    Hindi: [
      { value: 'Beginner (0-2 years)', label: 'рд╢реБрд░реБрдЖрддреА (0-2 рд╕рд╛рд▓)' },
      { value: 'Intermediate (3-10 years)', label: 'рдордзреНрдпрдо (3-10 рд╕рд╛рд▓)' },
      { value: 'Experienced (10+ years)', label: 'рдЕрдиреБрднрд╡реА (10+ рд╕рд╛рд▓)' }
    ],
    Punjabi: [
      { value: 'Beginner (0-2 years)', label: 'ри╕ри╝рйБри░рйВриЖридрйА (0-2 ри╕ри╛ри▓)' },
      { value: 'Intermediate (3-10 years)', label: 'риорй▒ризрио (3-10 ри╕ри╛ри▓)' },
      { value: 'Experienced (10+ years)', label: 'ридриЬри░римрйЗриХри╛ри░ (10+ ри╕ри╛ри▓)' }
    ]
  };

  private genAI!: GoogleGenerativeAI;
  private model: any;

  constructor(
    private formBuilder: FormBuilder,
    private toastController: ToastController,
    private loadingController: LoadingController,
    private alertController: AlertController,
    private http: HttpClient
  ) {
    // Initialize Google Generative AI
    const apiKey = environment.geminiApiKey;
    if (apiKey && apiKey !== 'YOUR_GEMINI_API_KEY') {
      this.genAI = new GoogleGenerativeAI(apiKey);
      this.model = this.genAI.getGenerativeModel({ model: 'gemini-2.5-pro' });
    }

    this.cropForm = this.formBuilder.group({
      location: ['', [Validators.required, Validators.minLength(2)]],
      soilType: ['', Validators.required],
      climate: ['', Validators.required],
      waterAvailability: ['', Validators.required],
      farmSize: ['', Validators.required],
      season: ['', Validators.required],
      budget: ['', [Validators.required, Validators.min(1000)]],
      experience: ['', Validators.required],
      previousCrops: [''],
      specificRequirements: [''],
      language: ['English', Validators.required]
    });
  }

  ngOnInit() {
    // Set default language and location from localStorage
    this.location = localStorage.getItem('city')+', '+localStorage.getItem('state');
    this.cropForm.patchValue({ language: 'English' });
    
    // Listen for language changes in the form
    this.cropForm.get('language')?.valueChanges.subscribe(language => {
      if (language) {
        this.currentLanguage = language;
      }
    });
    
    // Check if GenAI is properly initialized
    if (!this.model) {
      console.warn('Gemini AI not initialized. Please check your API key in environment file.');
    }
  }

  // Get current translations based on selected language
  get t() {
    return this.translations[this.currentLanguage as keyof typeof this.translations] || this.translations.English;
  }

  // Getter methods for translated options
  get soilTypes() {
    return this.soilTypesData[this.currentLanguage as keyof typeof this.soilTypesData] || this.soilTypesData.English;
  }

  get climateTypes() {
    return this.climateTypesData[this.currentLanguage as keyof typeof this.climateTypesData] || this.climateTypesData.English;
  }

  get waterSources() {
    return this.waterSourcesData[this.currentLanguage as keyof typeof this.waterSourcesData] || this.waterSourcesData.English;
  }

  get farmSizes() {
    return this.farmSizesData[this.currentLanguage as keyof typeof this.farmSizesData] || this.farmSizesData.English;
  }

  get seasons() {
    return this.seasonsData[this.currentLanguage as keyof typeof this.seasonsData] || this.seasonsData.English;
  }

  get experienceLevels() {
    return this.experienceLevelsData[this.currentLanguage as keyof typeof this.experienceLevelsData] || this.experienceLevelsData.English;
  }

  async getCropRecommendation() {
    if (this.cropForm.valid && !this.isSubmitting) {
      // Check if GenAI is initialized before proceeding
      if (!this.model) {
        await this.showToast('Gemini AI is not properly configured. Please contact administrator.', 'danger');
        return;
      }

      this.isSubmitting = true;
      
      const loading = await this.loadingController.create({
        message: 'Getting AI recommendations...',
        spinner: 'crescent'
      });
      await loading.present();

      try {
        const formData = this.cropForm.value;
        const prompt = this.buildGeminiPrompt(formData);
        
        const response = await this.callGeminiAI(prompt, formData.language);
        
        if (response) {
          this.aiResponse = response;
          this.showResponse = true;
          this.selectedLanguage = formData.language;
          await this.showToast('Crop recommendations generated successfully!', 'success');
        } else {
          await this.showToast('Failed to get recommendations. Please try again.', 'danger');
        }
      } catch (error: any) {
        console.error('Error getting crop recommendations:', error);
        
        // Show specific error message if available
        const errorMessage = error?.message || 'An error occurred. Please check your internet connection and try again.';
        await this.showToast(errorMessage, 'danger');
      } finally {
        await loading.dismiss();
        this.isSubmitting = false;
      }
    } else {
      await this.showValidationErrors();
    }
  }

  private buildGeminiPrompt(formData: any): string {
    const languageInstruction = this.getLanguageInstruction(formData.language);
    
    return `You are an expert agricultural advisor. Provide CONCISE crop recommendations for:

**Farm Details:**
- Location: ${formData.location}
- Soil: ${formData.soilType}, Climate: ${formData.climate}
- Water: ${formData.waterAvailability}, Size: ${formData.farmSize}
- Season: ${formData.season}, Budget: тВ╣${formData.budget}
- Experience: ${formData.experience}

**IMPORTANT: Keep response under 300 words. Provide:**

ЁЯМ╛ **TOP 2 CROPS:**
1. [Crop Name] - [2-line reason]
2. [Crop Name] - [2-line reason]

ЁЯТ░ **PROFIT POTENTIAL:**
- Expected return: [brief estimate]

ЁЯЪЬ **KEY TIPS:**
- [3 most important farming tips]

тЪая╕П **MAIN CHALLENGES:**
- [2 key challenges and solutions]

${languageInstruction}

Be concise, practical, and farmer-friendly.`;
  }

  private getLanguageInstruction(language: string): string {
    switch (language) {
      case 'Hindi':
        return 'рдХреГрдкрдпрд╛ рдЕрдкрдирд╛ рдЙрддреНрддрд░ рд╣рд┐рдВрджреА рдореЗрдВ рджреЗрдВред';
      case 'Punjabi':
        return 'риХри┐ри░рикри╛ риХри░риХрйЗ риЖрикригри╛ риЬри╡ри╛рим рикрй░риЬри╛римрйА ри╡ри┐рй▒риЪ рижри┐риУред';
      default:
        return 'Please provide your response in English.';
    }
  }

  private async callGeminiAI(prompt: string, language: string): Promise<string | null> {
    try {
      // Check if GenAI is properly initialized
      if (!this.model) {
        throw new Error('Gemini AI not properly initialized. Please check your API key.');
      }

      // Generate content using the official SDK
      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      const text = response.text();

      if (text && text.trim()) {
        return text;
      } else {
        throw new Error('Empty response from Gemini AI');
      }
    } catch (error: any) {
      console.error('Gemini AI API error:', error);
      
      // Handle specific error types
      if (error?.message?.includes('API_KEY_INVALID')) {
        throw new Error('Invalid Gemini API key. Please check your configuration.');
      } else if (error?.message?.includes('QUOTA_EXCEEDED')) {
        throw new Error('Gemini API quota exceeded. Please try again later.');
      } else if (error?.message?.includes('SAFETY')) {
        throw new Error('Content was blocked by safety filters. Please try with different input.');
      }
      
      return null;
    }
  }

  async showToast(message: string, color: string) {
    const toast = await this.toastController.create({
      message: message,
      duration: 3000,
      color: color,
      position: 'top'
    });
    await toast.present();
  }

  async showValidationErrors() {
    const errors: string[] = [];
    
    Object.keys(this.cropForm.controls).forEach(key => {
      const control = this.cropForm.get(key);
      if (control && control.invalid && (control.dirty || control.touched)) {
        if (control.errors?.['required']) {
          errors.push(`${this.getFieldLabel(key)} is required`);
        }
        if (control.errors?.['minlength']) {
          errors.push(`${this.getFieldLabel(key)} must be at least ${control.errors['minlength'].requiredLength} characters`);
        }
        if (control.errors?.['min']) {
          errors.push(`${this.getFieldLabel(key)} must be at least тВ╣${control.errors['min'].min}`);
        }
      }
    });

    if (errors.length > 0) {
      await this.showToast(errors.join('\n'), 'danger');
    }
  }

  private getFieldLabel(fieldName: string): string {
    const labels: {[key: string]: string} = {
      'location': 'Location',
      'soilType': 'Soil Type',
      'climate': 'Climate',
      'waterAvailability': 'Water Availability',
      'farmSize': 'Farm Size',
      'season': 'Season',
      'budget': 'Budget',
      'experience': 'Experience',
      'language': 'Language'
    };
    return labels[fieldName] || fieldName;
  }

  isFieldInvalid(fieldName: string): boolean {
    const field = this.cropForm.get(fieldName);
    return !!(field && field.invalid && (field.dirty || field.touched));
  }

  resetForm() {
    this.stopSpeech();
    this.cropForm.reset();
    this.cropForm.patchValue({ language: 'English' });
    this.aiResponse = '';
    this.showResponse = false;
    this.showFullResponse = false;
    this.isSubmitting = false;
  }

  // ElevenLabs Text-to-Speech functionality
  async toggleSpeech() {
    if (this.isPlaying) {
      this.stopSpeech();
    } else {
      await this.startSpeech();
    }
  }

  async startSpeech() {
    if (!this.aiResponse) {
      await this.showToast('No content to read', 'warning');
      return;
    }

    // Check if ElevenLabs API key is configured
    const apiKey = environment.elevenLabsApiKey;
    if (!apiKey || apiKey === 'YOUR_ELEVENLABS_API_KEY') {
      await this.showToast('ElevenLabs API key not configured', 'warning');
      return;
    }

    this.isGeneratingAudio = true;
    
    const loading = await this.loadingController.create({
      message: 'Generating high-quality audio...',
      spinner: 'crescent'
    });
    await loading.present();

    try {
      this.stopSpeech(); // Stop any current audio
      
      const cleanText = this.cleanTextForSpeech(this.aiResponse);
      const audioUrl = await this.generateElevenLabsAudio(cleanText);
      
      if (audioUrl) {
        // Dismiss loading before playing audio
        await loading.dismiss();
        await this.playAudio(audioUrl);
      } else {
        await loading.dismiss();
        await this.showToast('Failed to generate audio. Please try again.', 'danger');
      }
    } catch (error) {
      console.error('Speech generation error:', error);
      await loading.dismiss();
      await this.showToast('Error generating speech. Please check your connection.', 'danger');
    } finally {
      this.isGeneratingAudio = false;
    }
  }

  private async generateElevenLabsAudio(text: string): Promise<string | null> {
    try {
      const apiKey = environment.elevenLabsApiKey;
      
      // Get voice ID based on selected language
      const voiceId = this.getVoiceIdForLanguage(this.selectedLanguage);
      
      const response = await this.http.post(
        `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`,
        {
          text: text,
          model_id: 'eleven_multilingual_v2',
          voice_settings: {
            stability: 0.5,
            similarity_boost: 0.8,
            style: 0.2,
            use_speaker_boost: true
          }
        },
        {
          headers: {
            'xi-api-key': apiKey,
            'Content-Type': 'application/json'
          },
          responseType: 'blob'
        }
      ).toPromise();

      if (response) {
        // Create blob URL for audio playback
        const audioBlob = new Blob([response], { type: 'audio/mpeg' });
        return URL.createObjectURL(audioBlob);
      }
      
      return null;
    } catch (error) {
      console.error('ElevenLabs API error:', error);
      return null;
    }
  }

  private getVoiceIdForLanguage(language: string): string {
    // ElevenLabs voice IDs for different languages
    // Replace these with actual voice IDs from your ElevenLabs account
    switch (language) {
      case 'Hindi':
        return 'pNInz6obpgDQGcFmaJgB'; // Adam (multilingual)
      case 'Punjabi':
        return '21m00Tcm4TlvDq8ikWAM'; // Rachel (multilingual)
      default:
        return 'EXAVITQu4vr4xnSDxMaL'; // Bella (English)
    }
  }

  private async playAudio(audioUrl: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.currentAudio = new Audio(audioUrl);
      
      this.currentAudio.onloadstart = () => {
        this.isPlaying = true;
      };
      
      this.currentAudio.onended = () => {
        this.isPlaying = false;
        this.currentAudio = null;
        URL.revokeObjectURL(audioUrl); // Clean up blob URL
        resolve();
      };
      
      this.currentAudio.onerror = (error) => {
        this.isPlaying = false;
        this.currentAudio = null;
        URL.revokeObjectURL(audioUrl); // Clean up blob URL
        reject(error);
      };
      
      this.currentAudio.play().catch(reject);
    });
  }

  stopSpeech() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.currentAudio = null;
    }
    this.isPlaying = false;
  }


  private cleanTextForSpeech(text: string): string {
    return text
      .replace(/[ЁЯМ╛ЁЯТ░ЁЯЪЬтЪая╕П]/g, '') // Remove emojis
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold markdown
      .replace(/\*(.*?)\*/g, '$1') // Remove italic markdown
      .replace(/#{1,6}\s/g, '') // Remove headers
      .replace(/- /g, '') // Remove bullet points
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .trim();
  }

  toggleFullResponse() {
    this.showFullResponse = !this.showFullResponse;
  }

  getShortResponse(): string {
    if (!this.aiResponse) return '';
    const words = this.aiResponse.split(' ');
    return words.length > 50 ? words.slice(0, 50).join(' ') + '...' : this.aiResponse;
  }

  async shareRecommendations() {
    if (this.aiResponse) {
      const alert = await this.alertController.create({
        header: 'Share Recommendations',
        message: 'Choose how you want to share these crop recommendations:',
        buttons: [
          {
            text: 'Copy to Clipboard',
            handler: () => {
              navigator.clipboard.writeText(this.aiResponse);
              this.showToast('Recommendations copied to clipboard!', 'success');
            }
          },
          {
            text: 'Cancel',
            role: 'cancel'
          }
        ]
      });
      await alert.present();
    }
  }

  // Helper method to check GenAI configuration
  private isGenAIConfigured(): boolean {
    const apiKey = environment.geminiApiKey;
    return !!(apiKey && apiKey !== 'YOUR_GEMINI_API_KEY' && this.model);
  }

  // Method to test GenAI connection (can be called for debugging)
  async testGenAIConnection(): Promise<boolean> {
    try {
      if (!this.isGenAIConfigured()) {
        console.error('GenAI not properly configured');
        return false;
      }

      const result = await this.model.generateContent('Test connection');
      const response = await result.response;
      const text = response.text();
      
      console.log('GenAI connection test successful:', text.substring(0, 50) + '...');
      return true;
    } catch (error) {
      console.error('GenAI connection test failed:', error);
      return false;
    }
  }
}
